<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>CPU & RAM Interactive Simulator (Mobile)</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background: #f5f5f5;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .page-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 8px 0 54px 0; /* Added top padding to match side padding */
        }
        .sim-description {
            width: 100vw;
            box-sizing: border-box;
            text-align: center;
            font-size: 1.05em;
            color: #333;
            margin: 0;
            padding: 16px 8px 8px 8px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            margin: 0;
            padding: 0;
            align-items: stretch;
        }
        .ram, .cpu, .control-panel, .explanation-panel {
            border: 1px solid #ccc;
            padding: 12px 10px;
            border-radius: 8px;
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            margin: 0 8px 8px 8px;
        }
        
        /* Specific adjustment for RAM section to ensure even cell spacing */
        .ram {
            padding-left: 10px;
            padding-right: 10px;
        }
        .ram-cells {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(10, min-content);
            grid-auto-flow: column;
            column-gap: 8px;
            row-gap: 3px;
            margin-top: 6px;
            padding: 0;
            width: 100%;
            box-sizing: border-box;
        }
        .cell {
            width: 100%;
            min-width: 0;
            height: 22px;
            border: 1px solid #888;
            display: flex;
            align-items: center;
            background: #f9f9f9;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.78em;
            padding: 0 2px;
            box-sizing: border-box;
            margin: 0;
        }
        .cell.active {
            background: #ffe082;
            border-color: #ffa000;
        }
        .cell.referenced {
            background: #e3f2fd;
            border-color: #2196f3;
        }
        .cell-address {
            width: 28px;
            text-align: right;
            color: #888;
            font-size: 0.78em;
            padding-right: 2px;
            font-weight: normal;
        }
        .cell-content {
            flex: 1;
            text-align: left;
            padding-left: 2px;
            font-size: 0.78em;
        }
        .registers {
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 0 1px; /* Match RAM cells padding */
        }
        .register {
            background: #f0f4f8;
            border-radius: 6px;
            font-size: 0.78em;
            padding: 7px 12px;
            margin: 0;
            font-weight: 500;
            color: #222;
            box-shadow: 0 1px 2px rgba(0,0,0,0.03);
            border: 1px solid #e0e0e0;
            letter-spacing: 0.01em;
            display: grid;
            grid-template-columns: minmax(auto, 1fr) minmax(120px, auto);
            align-items: center;
            gap: 8px;
        }
        .register .label {
            color: #555;
        }
        .register .value {
            position: relative;
            text-align: right;
            font-family: 'Consolas', monospace;
            font-weight: 600;
            padding: 2px 4px;
            border-radius: 3px;
            min-width: 50px; /* Increased min-width for better alignment */
            width: 100%; /* Take full width of the grid cell */
            display: block; /* Block display for consistent sizing */
            box-sizing: border-box; /* Include padding in width calculation */
        }
        
        .section-header {
            font-size: 0.78em;
            font-weight: bold;
            margin-bottom: 6px;
            color: #444;
        }
        @keyframes valueChange {
            0% {
                background: rgba(33, 150, 243, 0);
            }
            15% {
                background: rgba(33, 150, 243, 0.15);
            }
            30% {
                background: rgba(33, 150, 243, 0);
            }
            45% {
                background: rgba(33, 150, 243, 0.15);
            }
            60% {
                background: rgba(33, 150, 243, 0);
            }
            75% {
                background: rgba(33, 150, 243, 0.15);
            }
            100% {
                background: rgba(33, 150, 243, 0);
            }
        }
        .value-changed {
            animation: valueChange 1.5s ease-out;
            border-radius: 3px;
            /* Remove padding and margin adjustments that could cause alignment issues */
        }
        .controls-tray {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100vw;
            height: 54px;
            background: #fff;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.08);
            display: flex;
            z-index: 100;
        }
        .controls-tray button {
            flex: 1 1 0;
            height: 100%;
            border: none;
            border-radius: 0;
            font-size: 1.05em;
            font-weight: bold;
            color: #fff;
            background: #1976d2;
            box-shadow: none;
            margin: 0;
            cursor: pointer;
            transition: background 0.2s, filter 0.2s;
        }
        .controls-tray button:last-child {
            background: #d32f2f;
        }
        .controls-tray button:active {
            filter: brightness(0.95);
        }
        .controls-tray button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .instruction { font-family: monospace; }
        .explanation-panel {
            min-height: 40px;
            margin: 2px 8px 8px 8px;
            display: flex;
            flex-direction: column-reverse; /* Stack items bottom-up */
        }
        .explanation-content {
            color: #444;
            font-size: 0.9em;
            line-height: 1.2;
            display: flex;
            flex-direction: column-reverse; /* Stack items bottom-up */
            gap: 8px;
        }
        .explanation-item {
            padding: 8px 12px;
            background: #fff;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            color: #444; /* All items use same color */
            display: flex;
            align-items: center; /* Center align items vertically */
            gap: 8px;
            font-size: 0.78em;
        }
        /* Modified style to ONLY target the latest explanation item's icon */
        .explanation-item:last-child .phase-icon svg {
            stroke: #1976d2; /* Match the blue button color */
            cursor: pointer; /* Add pointer cursor to indicate it's clickable */
        }
        /* No special styling for last explanation item - all appear instantly */
        .phase-icon {
            flex-shrink: 0;
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .phase-icon svg {
            width: 16px;
            height: 16px;
            display: block;
        }
        .explanation-text {
            flex: 1;
            min-width: 0;
            padding-top: 1px; /* Slight adjustment for text alignment */
        }
        /* Spinner animation for brief indication after button press */
        @keyframes spinner {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .spin {
            animation: spinner 1.6s linear; /* Increased from 0.8s to 1.6s (2x) */
            transform-origin: center;
            stroke: #1976d2; /* Set the stroke color to match the blue button */
        }
        h1, h2 {
            display: none;
        }
        @media (max-width: 400px) {
            .cell-address { width: 30px; font-size: 0.9em; }
            .cell-content { font-size: 0.9em; }
            .register { font-size: 0.95em; }
        }
    </style>
</head>
<body>
    <div class="page-content">
        <div class="container">
            <div class="cpu">
                <div class="section-header">CPU</div>
            <div class="registers">
                <div class="register">
                    <div class="label">Program Counter (PC)</div>
                    <div class="value" id="pc">0</div>
                </div>
                <div class="register">
                    <div class="label">Memory Address Register (MAR)</div>
                    <div class="value" id="mar">0x00</div>
                </div>
                <div class="register">
                    <div class="label">Memory Data Register (MDR)</div>
                    <div class="value" id="mdr">0</div>
                </div>
                <div class="register">
                    <div class="label">Accumulator (ACC)</div>
                    <div class="value" id="acc">0</div>
                </div>
            </div>
        </div>
        <div class="ram">
            <div class="section-header">RAM</div>
            <div id="ramCells" class="ram-cells"></div>
        </div>
        <div class="explanation-panel">
            <div id="instructionExplanation" class="explanation-content"></div>
            </div>
        </div>
    </div>

    <div class="controls-tray">
        <button id="cycleButton" onclick="window.cycleStep()">
            <span style="display:inline-flex;align-items:center;gap:6px;">
                <svg id="cycleIcon" xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg>
                <span id="cycleText">Fetch</span>
            </span>
        </button>
        <button onclick="window.resetSim(false)">
            <span style="display:inline-flex;align-items:center;gap:6px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
                Reset
            </span>
        </button>
    </div>

    <script>
    (function() {
        // Define phase metadata with icons and descriptions
        const phases = {
            'FETCH': {
                icon: '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/>',
                description: 'Fetching instruction from memory at address in PC'
            },
            'DECODE': {
                icon: '<circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/>',
                description: 'Decoding the instruction and preparing for execution'
            },
            'EXECUTE': {
                icon: '<polygon points="5 3 19 12 5 21 5 3"/>',
                description: 'Executing the decoded instruction'
            }
        };

        // Initialize simulation state
        window.mar = 0;  // Memory Address Register
        window.mdr = 0;  // Memory Data Register
        window.pc = 0;   // Program Counter
        window.acc = 0;  // Accumulator
        window.halted = false;
        window.currentPhase = 'FETCH';
        window.currentInstruction = '';
        window.currentArg = '';

        // Initial RAM setup
        window.ram = [
            'LOAD 0x10',  // Load initial value
            'ADD 0x11',   // Add second value
            'STORE 0x14', // Store sum
            'MUL 0x11',   // Multiply by second value
            'STORE 0x15', // Store product
            'DIV 0x13',   // Divide by fourth value
            'STORE 0x16', // Store quotient
            'SUB 0x11',   // Subtract second value
            'STORE 0x17', // Store difference
            'LOAD 0x14',  // Load sum back
            'MUL 0x11',   // Multiply by second value again
            'STORE 0x18', // Store final result
            'JUMP 0x00',  // Loop back to start
            'HLT',        // Halt (not reached due to jump)
            'HLT',
            0, 0, 0, 0, 0, 0,
            5,   // Initial value at 0x10
            3,   // Second value at 0x11
            10,  // Third value at 0x12
            4,   // Fourth value at 0x13
            0,   // Sum storage at 0x14
            0,   // Product storage at 0x15
            0,   // Quotient storage at 0x16
            0,   // Difference storage at 0x17
            0    // Final result storage at 0x18
        ];

        // Instruction explanations
        const getPhaseExplanation = () => {
            const currentOp = window.currentInstruction;
            const currentArg = window.currentArg;
            
            switch(window.currentPhase) {
                case 'FETCH':
                    return `FETCH: Set MAR = PC (0x${window.pc.toString(16).padStart(2, '0').toUpperCase()}), then copy instruction from RAM[0x${window.pc.toString(16).padStart(2, '0').toUpperCase()}] into MDR`;
                case 'DECODE':
                    return `DECODE: Parse instruction in MDR (${window.mdr}) to determine operation and address`;
                case 'EXECUTE':
                    if (currentOp === 'LOAD') {
                        return `EXECUTE LOAD: Set MAR = ${currentArg}, copy value from RAM to MDR, then copy MDR to ACC`;
                    } else if (currentOp === 'ADD') {
                        return `EXECUTE ADD: Set MAR = ${currentArg}, get value into MDR, then add MDR to ACC`;
                    } else if (currentOp === 'SUB') {
                        return `EXECUTE SUB: Set MAR = ${currentArg}, get value into MDR, then subtract MDR from ACC`;
                    } else if (currentOp === 'MUL') {
                        return `EXECUTE MUL: Set MAR = ${currentArg}, get value into MDR, then multiply ACC by MDR`;
                    } else if (currentOp === 'DIV') {
                        return `EXECUTE DIV: Set MAR = ${currentArg}, get value into MDR, then divide ACC by MDR`;
                    } else if (currentOp === 'STORE') {
                        return `EXECUTE STORE: Set MAR = ${currentArg}, copy ACC to MDR, then store MDR to RAM`;
                    } else if (currentOp === 'JUMP') {
                        return `EXECUTE JUMP: Set PC to ${currentArg}`;
                    } else if (currentOp === 'HLT') {
                        return `EXECUTE HALT: Stop CPU execution`;
                    } else if (currentOp === 'DATA') {
                        return `This is data, not an instruction`;
                    }
                    return 'Unknown instruction';
                default:
                    return 'Unknown phase';
            }
        };

        // UI update functions
        window.showExplanation = function(text) {
            const expl = document.getElementById('instructionExplanation');
            if (expl) {
                const item = document.createElement('div');
                item.classList.add('explanation-item');

                // Create icon container
                const iconContainer = document.createElement('div');
                iconContainer.classList.add('phase-icon');
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '16');
                svg.setAttribute('height', '16');
                svg.setAttribute('viewBox', '0 0 24 24');
                svg.setAttribute('fill', 'none');
                svg.setAttribute('stroke', 'currentColor'); // Use currentColor instead of hardcoded color
                svg.setAttribute('stroke-width', '2');
                svg.setAttribute('stroke-linecap', 'round');
                svg.setAttribute('stroke-linejoin', 'round');
                
                // Add the appropriate phase icon immediately (no spinner)
                if (text.includes('Program reset')) {
                    // For reset, use the reset icon
                    svg.innerHTML = '<polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>',
                    svg.setAttribute('stroke', '#1976d2'); // Set stroke to match button color
                } else {
                    // Use the current phase icon
                    const phase = phases[window.currentPhase];
                    if (phase) {
                        svg.innerHTML = phase.icon;
                    }
                }
                
                iconContainer.appendChild(svg);

                // Create text container
                const textContainer = document.createElement('div');
                textContainer.classList.add('explanation-text');
                textContainer.innerText = text;

                // Add icon and text to item
                item.appendChild(iconContainer);
                item.appendChild(textContainer);
                
                // Add to the end for correct chronological order (newest at the end)
                expl.appendChild(item);
                
                // Add click event to the latest icon (if it's the last item which gets the blue color)
                // This needs to be after appending to expl so :last-child CSS applies
                const latestSvg = expl.lastChild.querySelector('.phase-icon svg');
                if (latestSvg) {
                    latestSvg.addEventListener('click', function(e) {
                        if (!window.halted) {
                            window.cycleStep();
                        }
                        e.stopPropagation(); // Prevent event bubbling
                    });
                }

                // Keep only the last 10 explanations to prevent excessive memory use
                while (expl.children.length > 10) {
                    expl.removeChild(expl.firstChild);
                }
            }
        };

        window.render = function() {
            // Update RAM display
            const container = document.getElementById('ramCells');
            container.innerHTML = '';
            let referencedAddr = null;

            // Find referenced address from current instruction
            if (window.pc !== null && window.currentArg) {
                referencedAddr = parseInt(window.currentArg, 16);
            }

            // Create RAM cell elements
            for (let i = 0; i < window.ram.length; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                if (i === window.pc) {
                    cell.classList.add('active');
                }
                if (i === referencedAddr && window.currentPhase === 'EXECUTE') {
                    cell.classList.add('referenced');
                }

                const addr = document.createElement('div');
                addr.classList.add('cell-address');
                addr.innerText = '0x' + i.toString(16).padStart(2, '0').toUpperCase();

                const content = document.createElement('div');
                content.classList.add('cell-content');
                content.innerText = window.ram[i];

                cell.appendChild(addr);
                cell.appendChild(content);
                container.appendChild(cell);
            }

            // Track and update register displays with animation
            const registers = {
                'mar': { 
                    elem: document.getElementById('mar'),
                    value: '0x' + window.mar.toString(16).padStart(2, '0').toUpperCase(),
                    lastValue: window.marLast
                },
                'mdr': { 
                    elem: document.getElementById('mdr'),
                    value: window.mdr,
                    lastValue: window.mdrLast
                },
                'acc': { 
                    elem: document.getElementById('acc'),
                    value: window.acc,
                    lastValue: window.accLast
                },
                'pc': { 
                    elem: document.getElementById('pc'),
                    value: '0x' + window.pc.toString(16).padStart(2, '0').toUpperCase(),
                    lastValue: window.pcLast
                }
            };

            // Update each register and animate if changed
            Object.entries(registers).forEach(([key, reg]) => {
                if (reg.elem) {
                    // Always ensure text is right-aligned
                    reg.elem.innerText = reg.value;
                    
                    // Handle animation without affecting alignment
                    if (reg.value !== reg.lastValue) {
                        // Remove animation class and force reflow
                        reg.elem.classList.remove('value-changed');
                        void reg.elem.offsetWidth; // Force reflow
                        // Add animation class
                        reg.elem.classList.add('value-changed');
                    }
                }
            });

            // Store current values for next comparison
            window.marLast = registers.mar.value;
            window.mdrLast = registers.mdr.value;
            window.accLast = registers.acc.value;
            window.pcLast = registers.pc.value;

            // Update phase indicator
            const phase = phases[window.currentPhase];
            if (phase) {
                const cycleIcon = document.getElementById('cycleIcon');
                const cycleText = document.getElementById('cycleText');
                if (cycleIcon && cycleText) {
                    cycleIcon.innerHTML = phase.icon;
                    cycleText.innerText = window.currentPhase.charAt(0) + window.currentPhase.slice(1).toLowerCase();
                }
            }

            // Update explanation (only if phase changed)
            if (window.lastPhase !== window.currentPhase || window.halted) {
                const text = window.halted ? 'Program halted.' : getPhaseExplanation();
                
                // No delay - add explanation immediately
                window.showExplanation(text);
                
                window.lastPhase = window.currentPhase;
            }

            // Update UI for halted state
            const cycleButton = document.getElementById('cycleButton');
            if (cycleButton) {
                cycleButton.disabled = window.halted;
            }
        };

        window.cycleStep = function() {
            if (window.halted) return;
            
            // First, add spinner to the top explanation item when cycle button is pressed
            const expl = document.getElementById('instructionExplanation');
            if (expl && expl.children.length > 0) {
                // Get the most recent explanation item (last child)
                const latestItem = expl.lastChild;
                
                // Add a temporary spinning class to the icon in that item
                const phaseIcon = latestItem.querySelector('.phase-icon svg');
                if (phaseIcon) {
                    // Store original icon content
                    const originalIcon = phaseIcon.innerHTML;
                    
                    // Replace with spinner
                    phaseIcon.innerHTML = '<circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="1.5 3" />';
                    phaseIcon.classList.add('spin');
                    
                    // Restore after animation
                    setTimeout(function() {
                        phaseIcon.innerHTML = originalIcon;
                        phaseIcon.classList.remove('spin');
                    }, 600); // Increased from 300 to 600 (2x)
                }
            }

            switch(window.currentPhase) {
                case 'FETCH':
                    // Fetch phase: Load instruction from memory at PC into MDR
                    window.mar = window.pc;
                    window.mdr = window.ram[window.mar];
                    window.currentPhase = 'DECODE';
                    window.render();
                    break;

                case 'DECODE':
                    // Decode phase: Parse the instruction in MDR
                    if (typeof window.mdr === 'string') {
                        [window.currentInstruction, window.currentArg] = window.mdr.split(' ');
                    } else {
                        window.currentInstruction = 'DATA';
                        window.currentArg = window.mdr;
                    }
                    window.currentPhase = 'EXECUTE';
                    window.render();
                    break;

                case 'EXECUTE':
                    // Execute phase: Perform the instruction
                    if (window.currentInstruction === 'HLT') {
                        window.halted = true;
                        window.pc++;
                    } else if (window.currentInstruction === 'DATA') {
                        window.pc++;
                    } else {
                        const op = window.currentInstruction;
                        window.currentPhase = 'FETCH';  // Set next phase for next cycle
                        const arg = window.currentArg;
                        switch (op) {
                            case 'LOAD':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                window.acc = window.mdr;  // Load to accumulator
                                window.pc++;
                                break;
                            case 'ADD':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                window.acc += window.mdr;  // Add to accumulator
                                window.pc++;
                                break;
                            case 'SUB':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                window.acc -= window.mdr;  // Subtract from accumulator
                                window.pc++;
                                break;
                            case 'MUL':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                window.acc *= window.mdr;  // Multiply accumulator
                                window.pc++;
                                break;
                            case 'DIV':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                if (window.mdr !== 0) {
                                    window.acc = Math.floor(window.acc / window.mdr);  // Integer division
                                }
                                window.pc++;
                                break;
                            case 'STORE':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.acc;  // Load ACC into MDR
                                window.ram[window.mar] = window.mdr;  // Store to memory
                                window.pc++;
                                break;
                            case 'JUMP':
                                window.pc = parseInt(arg, 16);
                                break;
                        }
                        window.currentPhase = 'FETCH';  // Reset cycle for next instruction
                    }
                    break;
            }
            window.render();
        };

        window.resetSim = function(isInitialLoad) {
            // Reset RAM data values
            window.ram[0x10] = 5;   // Initial value
            window.ram[0x11] = 3;   // Second value
            window.ram[0x12] = 10;  // Third value
            window.ram[0x13] = 4;   // Fourth value
            window.ram[0x14] = 0;   // Sum storage
            window.ram[0x15] = 0;   // Product storage
            window.ram[0x16] = 0;   // Quotient storage
            window.ram[0x17] = 0;   // Difference storage
            window.ram[0x18] = 0;   // Final result storage

            // Reset CPU state
            window.pc = 0;
            window.acc = 0;
            window.mar = 0;
            window.mdr = 0;
            window.halted = false;
            window.currentPhase = 'FETCH';
            window.lastPhase = '';  // Initialize lastPhase
            window.currentInstruction = '';
            window.currentArg = '';

            // Initialize last values for change detection
            window.marLast = '0x0';
            window.mdrLast = '0';
            window.accLast = '0';
            window.pcLast = '0x0';

            // Clear and reset UI
            const expl = document.getElementById('instructionExplanation');
            if (expl) {
                expl.innerHTML = ''; // Clear all explanations
                
                // Create a special explanation for reset with custom icon
                const item = document.createElement('div');
                item.classList.add('explanation-item');

                const iconContainer = document.createElement('div');
                iconContainer.classList.add('phase-icon');
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '16');
                svg.setAttribute('height', '16');
                svg.setAttribute('viewBox', '0 0 24 24');
                svg.setAttribute('fill', 'none');
                svg.setAttribute('stroke', 'currentColor'); // Use currentColor instead of hardcoded blue
                svg.setAttribute('stroke-width', '2');
                svg.setAttribute('stroke-linecap', 'round');
                svg.setAttribute('stroke-linejoin', 'round');
                
                if (isInitialLoad) {
                    // On initial load, just show the reset icon without spinner
                    svg.innerHTML = '<polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>';
                } else {
                    // Only show spinner if not initial load
                    svg.innerHTML = '<circle cx="12" cy="12" r="10" stroke-width="2" stroke-dasharray="1.5 3" />';
                    svg.classList.add('spin');
                    
                    // After brief moment, replace with reset icon
                    setTimeout(function() {
                        svg.innerHTML = '<polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>';
                        svg.classList.remove('spin');
                    }, 1600); // Increased from 800 to 1600 (2x)
                }
                
                iconContainer.appendChild(svg);

                const textContainer = document.createElement('div');
                textContainer.classList.add('explanation-text');
                textContainer.innerText = 'Program reset. Ready to start!';

                item.appendChild(iconContainer);
                item.appendChild(textContainer);
                expl.appendChild(item);
                
                // Add click event to the icon in the reset explanation
                const resetSvg = expl.lastChild.querySelector('.phase-icon svg');
                if (resetSvg) {
                    resetSvg.addEventListener('click', function(e) {
                        if (!window.halted) {
                            window.cycleStep();
                        }
                        e.stopPropagation(); // Prevent event bubbling
                    });
                }
            }
            const cycleButton = document.getElementById('cycleButton');
            if (cycleButton) {
                cycleButton.disabled = false;
            }
            window.render();
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            window.resetSim(true); // Pass true to indicate initial page load
        });
    })();
    </script>
</body>
</html>