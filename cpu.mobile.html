<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>CPU & RAM Interactive Simulator (Mobile)</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            background: #f5f5f5;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .page-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding-bottom: 54px; /* Height of the controls tray */
        }
        .sim-description {
            width: 100vw;
            box-sizing: border-box;
            text-align: center;
            font-size: 1.05em;
            color: #333;
            margin: 0;
            padding: 16px 8px 8px 8px;
        }
        .container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            width: 100%;
            margin: 0;
            padding: 0;
            align-items: stretch;
        }
        .ram, .cpu, .control-panel, .explanation-panel {
            border: 1px solid #ccc;
            padding: 12px 8px;
            border-radius: 8px;
            background: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.08);
            margin: 0 8px 8px 8px;
        }
        .ram-cells {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(10, min-content);
            grid-auto-flow: column;
            column-gap: 8px;
            row-gap: 3px;
            margin-top: 2px;
        }
        .cell {
            width: 100%;
            min-width: 0;
            height: 22px;
            border: 1px solid #888;
            display: flex;
            align-items: center;
            background: #f9f9f9;
            border-radius: 3px;
            font-weight: bold;
            font-size: 0.78em;
            padding: 0 2px;
        }
        .cell.active {
            background: #ffe082;
            border-color: #ffa000;
        }
        .cell.referenced {
            background: #e3f2fd;
            border-color: #2196f3;
        }
        .cell-address {
            width: 28px;
            text-align: right;
            color: #888;
            font-size: 0.78em;
            padding-right: 2px;
            font-weight: normal;
        }
        .cell-content {
            flex: 1;
            text-align: left;
            padding-left: 2px;
            font-size: 0.78em;
        }
        .registers {
            margin-top: 6px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .register {
            background: #f0f4f8;
            border-radius: 6px;
            font-size: 1em;
            padding: 7px 12px;
            margin: 0;
            font-weight: 500;
            color: #222;
            box-shadow: 0 1px 2px rgba(0,0,0,0.03);
            border: 1px solid #e0e0e0;
            letter-spacing: 0.01em;
            display: grid;
            grid-template-columns: minmax(auto, 1fr) minmax(120px, auto);
            align-items: center;
            gap: 8px;
        }
        .register .label {
            color: #555;
        }
        .register .value {
            position: relative;
            text-align: right;
            font-family: 'Consolas', monospace;
            font-weight: 600;
            padding: 2px 4px;
            border-radius: 3px;
        }
        @keyframes valueChange {
            0% {
                background: rgba(33, 150, 243, 0);
            }
            30% {
                background: rgba(33, 150, 243, 0.1);
            }
            100% {
                background: rgba(33, 150, 243, 0);
            }
        }
        .value-changed {
            animation: valueChange 0.8s ease-out;
            border-radius: 3px;
            padding: 2px 4px;
            margin: -2px -4px;
        }
        .controls-tray {
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100vw;
            height: 54px;
            background: #fff;
            box-shadow: 0 -2px 10px rgba(0,0,0,0.08);
            display: flex;
            z-index: 100;
        }
        .controls-tray button {
            flex: 1 1 0;
            height: 100%;
            border: none;
            border-radius: 0;
            font-size: 1.05em;
            font-weight: bold;
            color: #fff;
            background: #1976d2;
            box-shadow: none;
            margin: 0;
            cursor: pointer;
            transition: background 0.2s, filter 0.2s;
        }
        .controls-tray button:last-child {
            background: #d32f2f;
        }
        .controls-tray button:active {
            filter: brightness(0.95);
        }
        .controls-tray button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .instruction { font-family: monospace; }
        .explanation-panel {
            min-height: 40px;
            margin: 2px 8px 8px 8px;
            display: flex;
            flex-direction: column-reverse; /* Stack items bottom-up */
        }
        .explanation-content {
            color: #444;
            font-size: 0.9em;
            line-height: 1.2;
            display: flex;
            flex-direction: column-reverse; /* Stack items bottom-up */
            gap: 8px;
        }
        .explanation-item {
            padding: 8px 12px;
            background: #fff;
            border-radius: 6px;
            border: 1px solid #e0e0e0;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            opacity: 0;
            animation: fadeIn 0.8s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            transition: color 0.3s ease-out;
            color: #888; /* Historical entries have lighter text */
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }
        .explanation-item:last-child {
            color: #444; /* Latest entry has darker text */
        }
        .phase-icon {
            flex-shrink: 0;
            width: 16px;
            height: 16px;
            margin-top: 2px;
        }
        .phase-icon svg {
            width: 16px;
            height: 16px;
            display: block;
        }
        .explanation-text {
            flex: 1;
            min-width: 0;
        }
        @keyframes fadeIn {
            0% {
                opacity: 0;
            }
            50% {
                opacity: 0.6;
            }
            100% {
                opacity: 1;
            }
        }
        h1, h2 {
            display: none;
        }
        @media (max-width: 400px) {
            .cell-address { width: 30px; font-size: 0.9em; }
            .cell-content { font-size: 0.9em; }
            .register { font-size: 0.95em; }
        }
    </style>
</head>
<body>
    <div class="page-content">
        <div class="container">
            <div class="cpu">
                <div style="font-size:1em;font-weight:bold;margin-bottom:2px;">CPU</div>
            <div class="registers">
                <div class="register">
                    <div class="label">Memory Address Register (MAR)</div>
                    <div class="value" id="mar">0x0</div>
                </div>
                <div class="register">
                    <div class="label">Memory Data Register (MDR)</div>
                    <div class="value" id="mdr">0</div>
                </div>
                <div class="register">
                    <div class="label">Accumulator (ACC)</div>
                    <div class="value" id="acc">0</div>
                </div>
                <div class="register">
                    <div class="label">Program Counter (PC)</div>
                    <div class="value" id="pc">0</div>
                </div>
            </div>
        </div>
        <div class="ram">
            <div style="font-size:1em;font-weight:bold;margin-bottom:2px;">RAM</div>
            <div id="ramCells" class="ram-cells"></div>
        </div>
        <div class="explanation-panel">
            <div id="instructionExplanation" class="explanation-content"></div>
            </div>
        </div>
    </div>

    <div class="controls-tray">
        <button id="cycleButton" onclick="window.cycleStep()">
            <span style="display:inline-flex;align-items:center;gap:6px;">
                <svg id="cycleIcon" xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></svg>
                <span id="cycleText">Fetch</span>
            </span>
        </button>
        <button onclick="window.resetSim()">
            <span style="display:inline-flex;align-items:center;gap:6px;">
                <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
                Reset
            </span>
        </button>
    </div>

    <script>
    (function() {
        // Define phase metadata with icons and descriptions
        const phases = {
            'FETCH': {
                icon: '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"/><polyline points="22,6 12,13 2,6"/>',
                description: 'Fetching instruction from memory at address in PC'
            },
            'DECODE': {
                icon: '<circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/>',
                description: 'Decoding the instruction and preparing for execution'
            },
            'EXECUTE': {
                icon: '<polygon points="5 3 19 12 5 21 5 3"/>',
                description: 'Executing the decoded instruction'
            }
        };

        // Initialize simulation state
        window.mar = 0;  // Memory Address Register
        window.mdr = 0;  // Memory Data Register
        window.pc = 0;   // Program Counter
        window.acc = 0;  // Accumulator
        window.halted = false;
        window.currentPhase = 'FETCH';
        window.currentInstruction = '';
        window.currentArg = '';

        // Initial RAM setup
        window.ram = [
            'LOAD 0x10',  // Load initial value
            'ADD 0x11',   // Add second value
            'STORE 0x14', // Store sum
            'MUL 0x11',   // Multiply by second value
            'STORE 0x15', // Store product
            'DIV 0x13',   // Divide by fourth value
            'STORE 0x16', // Store quotient
            'SUB 0x11',   // Subtract second value
            'STORE 0x17', // Store difference
            'LOAD 0x14',  // Load sum back
            'MUL 0x11',   // Multiply by second value again
            'STORE 0x18', // Store final result
            'JUMP 0x00',  // Loop back to start
            'HLT',        // Halt (not reached due to jump)
            'HLT',
            0, 0, 0, 0, 0, 0,
            5,   // Initial value at 0x10
            3,   // Second value at 0x11
            10,  // Third value at 0x12
            4,   // Fourth value at 0x13
            0,   // Sum storage at 0x14
            0,   // Product storage at 0x15
            0,   // Quotient storage at 0x16
            0,   // Difference storage at 0x17
            0    // Final result storage at 0x18
        ];

        // Instruction explanations
        const getPhaseExplanation = () => {
            const currentOp = window.currentInstruction;
            const currentArg = window.currentArg;
            
            switch(window.currentPhase) {
                case 'FETCH':
                    return `FETCH: Set MAR = PC (${window.pc}), then copy instruction from RAM[${window.pc}] into MDR`;
                case 'DECODE':
                    return `DECODE: Parse instruction in MDR (${window.mdr}) to determine operation and address`;
                case 'EXECUTE':
                    if (currentOp === 'LOAD') {
                        return `EXECUTE LOAD: Set MAR = ${currentArg}, copy value from RAM to MDR, then copy MDR to ACC`;
                    } else if (currentOp === 'ADD') {
                        return `EXECUTE ADD: Set MAR = ${currentArg}, get value into MDR, then add MDR to ACC`;
                    } else if (currentOp === 'SUB') {
                        return `EXECUTE SUB: Set MAR = ${currentArg}, get value into MDR, then subtract MDR from ACC`;
                    } else if (currentOp === 'MUL') {
                        return `EXECUTE MUL: Set MAR = ${currentArg}, get value into MDR, then multiply ACC by MDR`;
                    } else if (currentOp === 'DIV') {
                        return `EXECUTE DIV: Set MAR = ${currentArg}, get value into MDR, then divide ACC by MDR`;
                    } else if (currentOp === 'STORE') {
                        return `EXECUTE STORE: Set MAR = ${currentArg}, copy ACC to MDR, then store MDR to RAM`;
                    } else if (currentOp === 'JUMP') {
                        return `EXECUTE JUMP: Set PC to ${currentArg}`;
                    } else if (currentOp === 'HLT') {
                        return `EXECUTE HALT: Stop CPU execution`;
                    } else if (currentOp === 'DATA') {
                        return `This is data, not an instruction`;
                    }
                    return 'Unknown instruction';
                default:
                    return 'Unknown phase';
            }
        };

        // UI update functions
        window.showExplanation = function(text) {
            const expl = document.getElementById('instructionExplanation');
            if (expl) {
                const item = document.createElement('div');
                item.classList.add('explanation-item');

                // Create icon container
                const iconContainer = document.createElement('div');
                iconContainer.classList.add('phase-icon');
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '16');
                svg.setAttribute('height', '16');
                svg.setAttribute('viewBox', '0 0 24 24');
                svg.setAttribute('fill', 'none');
                svg.setAttribute('stroke', 'currentColor');
                svg.setAttribute('stroke-width', '2');
                svg.setAttribute('stroke-linecap', 'round');
                svg.setAttribute('stroke-linejoin', 'round');
                
                // Get current phase icon
                const phase = phases[window.currentPhase];
                if (phase) {
                    svg.innerHTML = phase.icon;
                }
                iconContainer.appendChild(svg);

                // Create text container
                const textContainer = document.createElement('div');
                textContainer.classList.add('explanation-text');
                textContainer.innerText = text;

                // Add icon and text to item
                item.appendChild(iconContainer);
                item.appendChild(textContainer);
                
                // Add to the end for correct chronological order (newest at the end)
                expl.appendChild(item);

                // Keep only the last 10 explanations to prevent excessive memory use
                while (expl.children.length > 10) {
                    expl.removeChild(expl.firstChild);
                }
            }
        };

        window.render = function() {
            // Update RAM display
            const container = document.getElementById('ramCells');
            container.innerHTML = '';
            let referencedAddr = null;

            // Find referenced address from current instruction
            if (window.pc !== null && window.currentArg) {
                referencedAddr = parseInt(window.currentArg, 16);
            }

            // Create RAM cell elements
            for (let i = 0; i < window.ram.length; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                if (i === window.pc) {
                    cell.classList.add('active');
                }
                if (i === referencedAddr && window.currentPhase === 'EXECUTE') {
                    cell.classList.add('referenced');
                }

                const addr = document.createElement('div');
                addr.classList.add('cell-address');
                addr.innerText = '0x' + i.toString(16).toUpperCase();

                const content = document.createElement('div');
                content.classList.add('cell-content');
                content.innerText = window.ram[i];

                cell.appendChild(addr);
                cell.appendChild(content);
                container.appendChild(cell);
            }

            // Track and update register displays with animation
            const registers = {
                'mar': { 
                    elem: document.getElementById('mar'),
                    value: '0x' + window.mar.toString(16).toUpperCase(),
                    lastValue: window.marLast
                },
                'mdr': { 
                    elem: document.getElementById('mdr'),
                    value: window.mdr,
                    lastValue: window.mdrLast
                },
                'acc': { 
                    elem: document.getElementById('acc'),
                    value: window.acc,
                    lastValue: window.accLast
                },
                'pc': { 
                    elem: document.getElementById('pc'),
                    value: '0x' + window.pc.toString(16).toUpperCase(),
                    lastValue: window.pcLast
                }
            };

            // Update each register and animate if changed
            Object.entries(registers).forEach(([key, reg]) => {
                if (reg.elem) {
                    reg.elem.innerText = reg.value;
                    if (reg.value !== reg.lastValue) {
                        reg.elem.classList.remove('value-changed');
                        void reg.elem.offsetWidth; // Force reflow
                        reg.elem.classList.add('value-changed');
                    }
                }
            });

            // Store current values for next comparison
            window.marLast = registers.mar.value;
            window.mdrLast = registers.mdr.value;
            window.accLast = registers.acc.value;
            window.pcLast = registers.pc.value;

            // Update phase indicator
            const phase = phases[window.currentPhase];
            if (phase) {
                const cycleIcon = document.getElementById('cycleIcon');
                const cycleText = document.getElementById('cycleText');
                if (cycleIcon && cycleText) {
                    cycleIcon.innerHTML = phase.icon;
                    cycleText.innerText = window.currentPhase.charAt(0) + window.currentPhase.slice(1).toLowerCase();
                }
            }

            // Update explanation (only if phase changed)
            if (window.lastPhase !== window.currentPhase || window.halted) {
                const text = window.halted ? 'Program halted.' : getPhaseExplanation();
                window.showExplanation(text);
                window.lastPhase = window.currentPhase;
            }

            // Update UI for halted state
            const cycleButton = document.getElementById('cycleButton');
            if (cycleButton) {
                cycleButton.disabled = window.halted;
            }
        };

        window.cycleStep = function() {
            if (window.halted) return;

            switch(window.currentPhase) {
                case 'FETCH':
                    // Fetch phase: Load instruction from memory at PC into MDR
                    window.mar = window.pc;
                    window.mdr = window.ram[window.mar];
                    window.currentPhase = 'DECODE';
                    window.render();
                    break;

                case 'DECODE':
                    // Decode phase: Parse the instruction in MDR
                    if (typeof window.mdr === 'string') {
                        [window.currentInstruction, window.currentArg] = window.mdr.split(' ');
                    } else {
                        window.currentInstruction = 'DATA';
                        window.currentArg = window.mdr;
                    }
                    window.currentPhase = 'EXECUTE';
                    window.render();
                    break;

                case 'EXECUTE':
                    // Execute phase: Perform the instruction
                    if (window.currentInstruction === 'HLT') {
                        window.halted = true;
                        window.pc++;
                    } else if (window.currentInstruction === 'DATA') {
                        window.pc++;
                    } else {
                        const op = window.currentInstruction;
                        window.currentPhase = 'FETCH';  // Set next phase for next cycle
                        const arg = window.currentArg;
                        switch (op) {
                            case 'LOAD':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                window.acc = window.mdr;  // Load to accumulator
                                window.pc++;
                                break;
                            case 'ADD':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                window.acc += window.mdr;  // Add to accumulator
                                window.pc++;
                                break;
                            case 'SUB':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                window.acc -= window.mdr;  // Subtract from accumulator
                                window.pc++;
                                break;
                            case 'MUL':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                window.acc *= window.mdr;  // Multiply accumulator
                                window.pc++;
                                break;
                            case 'DIV':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.ram[window.mar];  // Fetch from memory
                                if (window.mdr !== 0) {
                                    window.acc = Math.floor(window.acc / window.mdr);  // Integer division
                                }
                                window.pc++;
                                break;
                            case 'STORE':
                                window.mar = parseInt(arg, 16);  // Set memory address
                                window.mdr = window.acc;  // Load ACC into MDR
                                window.ram[window.mar] = window.mdr;  // Store to memory
                                window.pc++;
                                break;
                            case 'JUMP':
                                window.pc = parseInt(arg, 16);
                                break;
                        }
                        window.currentPhase = 'FETCH';  // Reset cycle for next instruction
                    }
                    break;
            }
            window.render();
        };

        window.resetSim = function() {
            // Reset RAM data values
            window.ram[0x10] = 5;   // Initial value
            window.ram[0x11] = 3;   // Second value
            window.ram[0x12] = 10;  // Third value
            window.ram[0x13] = 4;   // Fourth value
            window.ram[0x14] = 0;   // Sum storage
            window.ram[0x15] = 0;   // Product storage
            window.ram[0x16] = 0;   // Quotient storage
            window.ram[0x17] = 0;   // Difference storage
            window.ram[0x18] = 0;   // Final result storage

            // Reset CPU state
            window.pc = 0;
            window.acc = 0;
            window.mar = 0;
            window.mdr = 0;
            window.halted = false;
            window.currentPhase = 'FETCH';
            window.lastPhase = '';  // Initialize lastPhase
            window.currentInstruction = '';
            window.currentArg = '';

            // Initialize last values for change detection
            window.marLast = '0x0';
            window.mdrLast = '0';
            window.accLast = '0';
            window.pcLast = '0x0';

            // Clear and reset UI
            const expl = document.getElementById('instructionExplanation');
            if (expl) {
                expl.innerHTML = ''; // Clear all explanations
                
                // Create a special explanation for reset with custom icon
                const item = document.createElement('div');
                item.classList.add('explanation-item');

                const iconContainer = document.createElement('div');
                iconContainer.classList.add('phase-icon');
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.setAttribute('width', '16');
                svg.setAttribute('height', '16');
                svg.setAttribute('viewBox', '0 0 24 24');
                svg.setAttribute('fill', 'none');
                svg.setAttribute('stroke', 'currentColor');
                svg.setAttribute('stroke-width', '2');
                svg.setAttribute('stroke-linecap', 'round');
                svg.setAttribute('stroke-linejoin', 'round');
                
                // Same reset icon as the reset button
                svg.innerHTML = '<polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>';
                
                iconContainer.appendChild(svg);

                const textContainer = document.createElement('div');
                textContainer.classList.add('explanation-text');
                textContainer.innerText = 'Program reset. Ready to start!';

                item.appendChild(iconContainer);
                item.appendChild(textContainer);
                expl.appendChild(item);
            }
            const cycleButton = document.getElementById('cycleButton');
            if (cycleButton) {
                cycleButton.disabled = false;
            }
            window.render();
        };

        // Initialize on load
        document.addEventListener('DOMContentLoaded', function() {
            window.resetSim();
        });
    })();
    </script>
</body>
</html>